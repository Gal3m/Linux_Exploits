# Linux_Exploits
Real World Senario of Linux Exploits

1 Overview
It is recommended that this project be done by pairs of students. You can, of course, choose to do it
individually, but it is obviously going to be more work. Besides, exploit writing is an inexact process, so
there may be times when you get stuck. With two people working on the assignment, it is less likely that
both will get stuck in the same way; and even if you do, you can work in parallel to find a work-around.
The grading criteria will be different for individuals and pairs: for individuals, fewer parts will be mandatory, while the remaining parts will fetch bonus credits. More specifics about bonus points will be posted in
the next few days.
I anticipate that this will be the longest of all programming assignments, and so it will carry more points
than the other assignment. Plan on starting the work on this assignment right away.
You are given a vulnerable program vuln.c and a vulnerable heap implementation my malloc.c. These
programs, together with a Makefile, are provided as a tar-gzipped archive. Note that vuln accepts commands
on its input and executes them. Examine the source code to see what the commands are. (Until you read
that code, you cannot fully understand the rest of this assignment description.)
You are permitted to discuss the problem on Piazza, but don’t go to the level of posting your code.
You can post a small snippet that you are trying to understand or have difficulty with, and others can
clarify/explain. Unless you do the assignment yourself, you will have a hard time solving some of the
problems in your exams. Also note that memory layouts are different for each group/individual, so the
exploit that works for one group will fail for another group. This variation is implemented using the
environment variable GRP ID that should contain your group’s group id. (By default, it will be the last three
digits of the ID number of the team member whose last name is alphabetically the first among the group
members. Course staff will contact you if there is a difference from this default.) Since the exploits are
different with different groups, I can make a fully working sample exploit for the data-only exploit. This
exploit works when you set GRP ID to 1000. This example will give you a road map on how to construct
your exploit code, and how to structure it.
Note that vuln uses read rather than scanf or gets. This means you can input arbitrary values as
input, a capability you need if you want to input arbitrary binary data that may include code or pointer
values.
There are three basic vulnerabilities that you can exploit:
 a format string vulnerability in main loop,
 a heap overflow vulnerability in the version of malloc defined in my malloc.c and used in vuln.c,
 a stack overflow vulnerability in auth.
Some of these vulnerabilities can be exploited in more than one way.
Note that you don’t need to disable ASLR, stack protection or fool around with W ⊕ X to get your
exploits to work. Instead, you will use the printf and buffer overflow vulnerability to leak as much of the
memory contents as you want. Initially, you will leak the contents of the stack. The stack will contain stack
cookie | gcc uses the same value of the cookie for all functions, so you can read and reuse them. The
1stack will also contain saved base pointer. By reading it, you can overcome randomization of the stack base
address. To cope with possible randomization of code memory, you can read the return addresses off the
stack. By dumping code memory, you can read information such as the address of functions in libraries (e.g.,
bcopy), and from there, you can compute the location of a more useful function such as execl. Finally,
to overcome W ⊕ X, note that the Makefile already makes the stack executable. In addition, my malloc
ensures that its heap blocks are executable.
Note that Makefile automatically disassembles the vulnerable executable vuln to produce vuln.dis. To
make the assembly file easier to understand, it embeds source code lines within assembly, so that you will
know what line of source code results in which assembly instructions. The disassembly is produced by the
objdump tool. (See the Makefile for details.)
2 Stack Smashing
Using the buffer overflow vulnerability in auth, implement the following:
 Use a data-only-attack on the local variable db in the auth function. In particular, use stack smashing
in auth to overwrite db so that it points to the location of another local variable cred of auth. This
causes the chkPw function to be called with two identical arguments, it which case it will always
return true. By subverting the checking logic this way, an attacker can login without providing a valid
username or password.
{ This attack does not corrupt any critical data on the stack: no cookies or return addresses are
affected.
{ You are given a working version of this exploit for GRP ID 1000. You need to modify it so that it
works for your group’s id.
There will be a few additional parts to this assignment, and the details will be posted in
the next day or two. But it is important that you get started right away since there is a lot
of new material to absorb.
3 Submission
Your submission will be in the form of C-programs. In particular, for each exploit, you will create a version
of the driver program. Compiling and running this exploit program should lead to a successful exploit. Note
that you need to submit the source code for the exploits. You should not change vuln.c or any of the other
material provided to you.
You should create a tar-gzipped archive of all your exploit programs. Give them descriptive names such
as driver-smash-data.c, driver-heap.c, etc.
Submission will be on Blackboard, and the details will be provided to you.
4 Tips
 Use the 64-bit VM image provided to you. Your submission will be tested on this VM, so you might
as well work on the same VM.
 Don’t change the Makefile, except possibly for adding additional lines for compiling additional
exploit programs.
 Review carefully the example exploit program driver_auth_db.c. You will gain a better
understanding of how to structure your exploits, and also save time on other exploits.
2 You can print a specific offset that is, say, 100 words from the top of the stack using printf("%100$x")
instead of having to use 100 instances of %x’s. (Note that this may end up printing something that is
a few words off, say, 97 words from the top of the stack.)
 Within gdb, registers can be accessed by prefixing them with $, e.g., print $rsp will print the stack
pointer register.
 Within gdb, you can print arbitrary memory locations by casting them into pointers and dereferencing them, e.g., print *(int *)0xbfffff7c. You can control the format, e.g., print it in hex using
print /x *(int *)0xbfffff7c.
 To print many memory locations, use the x command. For instance, x /16x $rsp will dump 16 words
from memory, starting from the address in the stack pointer register. The second x in the command
indicates that you want the values printed hex format.
 Parameter passing convention in 64-bit Linux/x86: The registers RDI, RSI, RDX, RCX, R8, and R9
are used for passing the first six integer-type arguments. Arguments 7+ will be passed on the stack.
(Floating point arguments are passed in other registers, but you don’t have to worry about floats in
this assignment.)
 You need to use the printf vulnerability to leak several pieces of information. The first is the saved rbp
value that you need in order to figure out the base of the stack frames. (You cannot hard-code stack
base address because the stack base is (re)randomized on each execution.) The second is the return
address on the stack, or the address of library functions in the GOT (Global Offset Table).
The driver program is necessary because of the need to leak these pieces information. You will structure
your exploits as follows. First, you will use the e command to leak the above pieces of information.
You will extract the information into variables in the driver program, which will then construct an
exploit string and send it to vuln.
 You can debug an already running process by using gdb to attach to it. (On recent Linux versions,
you will need to run gdb as root in order to attach to an existing process.) To attach to an existing
process, e.g., vuln, type ps ax|grep vuln at the bash command prompt. It will produce a list of
processes that have the name vuln. Note down the pid, fire up gdb, and at its command line, type
attach to that pid.
This ability is invaluable for tracking down problems with your exploits.
 If you want to do the extra-credit problems, then first use objdump to disassemble the executable.
An executable contains code that won’t be in the object file vuln.o, or the assembly file vuln.s. Use
objdump -d vuln to disassemble the executable. Then you will see how library calls are made, and
how you can hijack them.
Although the stack and code layout is going to be different for each team, the layout does not change
from one run to another. So you can use gdb to figure out the layout once, and then use it repeatedly in
your exploits. Specifically, you need to know the size of the stack frames of main loop and auth, and you
can find this by running vuln within gdb, setting break points in these functions, and printing the values of
rbp and rsp registers. Make sure that you print rsp value after the calls to alloca. (This function allocates
storage on the stack, and hence will change the value of rsp.)
In order to succeed in this project, you have to get good at using gdb if you are not already
there.
34.1 Working with assembly/object code
Some exploits require you to use binary code. You can do this by writing a small assembly code snippet and
then compiling it using an assembler. One option is to use as, the default assembler on your system. You
can invoke it as:
as -a --64 test.s
where test.s is the file containing your assembly code. This command dumps the assembled code on
the screen. Note that as uses AT&T syntax for assembly. Alternatively, you can nasm which supports Intel
format. (I have not used nasm.)
Instead of trying to use direct jumps or calls to absolute memory locations, you should try to use indirect
jumps and indirect calls. First move the target address into a register, and then use an indirect jump or call
using that register. Various other points to note:
 Make sure you get your assembly syntax right for various addressing modes and operands. Specifically,
for as, make sure you prefix immediate operands with a $, and register operands with a %. For instance,
mov $0x20, %rax moves the decimal number 32 into the register rax, while mov 0x20, %rax moves
the contents of memory location 0x20 into rax. Also make sure that you use a * for indirect calls and
jumps, e.g., call *%rax is an indirect call to the address contained in rax. (However, call *(%rax)
first dereferences the location whose address is in rax, and then fetches the value stored at this memory
location, and then calls that location.)
 You can use gdb to work at the assembly level. You can use layout asm to see your code in assembly.
You can use stepi to single-step assembly instructions. To revert back into source code view, use
the command layout src. Here are two helpful references (just about two pages each) on gdb and
assembly code.
{ http://web.cecs.pdx.edu/~apt/cs491/gdb.pdf
{ https://sourceware.org/gdb/current/onlinedocs/gdb/Machine-Code.html
